<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Tomcat部署、Servlet原理，HTTP协议的请求响应"/>




  <meta name="keywords" content="Java,Web," />





  <link rel="alternate" href="/paranoiddemon.github.io/atom.xml" title="LANDFILL">




  <link rel="shortcut icon" type="image/x-icon" href="/paranoiddemon.github.io/favicon.ico?v=1.1" />



<link rel="canonical" href="https://paranoiddemon.github.io/blog/posts/tomcat-servlet-http-protocol.html"/>


<meta name="description" content="Tomcat部署、Servlet原理，HTTP协议的请求响应">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat、Servlet与HTTP协议">
<meta property="og:url" content="https://paranoiddemon.github.io/blog/posts/tomcat-servlet-http-protocol.html">
<meta property="og:site_name" content="LANDFILL">
<meta property="og:description" content="Tomcat部署、Servlet原理，HTTP协议的请求响应">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/07/07/jNUxvsRF36Z1p8V.png">
<meta property="og:image" content="https://i.loli.net/2020/07/07/P4LFV2aZ1toGn6f.png">
<meta property="article:published_time" content="2020-07-07T16:24:46.000Z">
<meta property="article:modified_time" content="2020-07-08T11:08:09.432Z">
<meta property="article:author" content="Demon">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/07/07/jNUxvsRF36Z1p8V.png">


<link rel="stylesheet" type="text/css" href="/paranoiddemon.github.io/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>


  <link rel="stylesheet" type="text/css" href="/paranoiddemon.github.io/lib/fancybox/jquery.fancybox.css" />




<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: true
    },
  };
</script>




  



    <title> Tomcat、Servlet与HTTP协议 - LANDFILL </title>
  <meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/paranoiddemon.github.io/atom.xml" title="LANDFILL" type="application/atom+xml">
</head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/paranoiddemon.github.io/." class="logo">LANDFILL</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/paranoiddemon.github.io/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/paranoiddemon.github.io/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Tomcat、Servlet与HTTP协议
        
      </h1>

      <time class="post-time">
          Jul 08 2020
      </time>
    </header>



    
            <div class="post-content">
            <p>本文内容：</p>
<ol>
<li>web相关概念</li>
<li>web服务器软件：Tomcat</li>
<li>Servlet</li>
<li>HTTP协议</li>
<li>Request</li>
<li>Response</li>
</ol>
<h2 id="web相关概念"><a href="#web相关概念" class="headerlink" title="web相关概念"></a>web相关概念</h2><ol>
<li>软件架构<br>C/S 客户端<br>B/S 浏览器</li>
<li>资源分类<br>静态资源：所有用户访问后得到的效果是一样的   如：html css js，可以直接被浏览器解析，客户端请求<br>动态资源: 每个用户访问相同资源后，得到的结果可能不一样。 动态资源先转换为静态资源，再返回（服务端响应）给浏览器解析 如servlet/jsp php asp</li>
<li>网络通信三要素<br>IP：计算机等网络设备在网络中的唯一标识<br>端口：应用程序的在计算机中的唯一标识 0-65536<br>协议：规定了数据通信的规则      如TCP/UDP</li>
</ol>
<h2 id="web服务器软件"><a href="#web服务器软件" class="headerlink" title="web服务器软件"></a>web服务器软件</h2><p>服务器：安装了服务器软件的计算机<br>服务器软件：接收用户的请求，处理请求，做出响应     如：mysql服务器，web服务器<br>web服务器软件：<br>    可以部署web项目，让用户通过浏览器来访问这些项目<br>    web容器，动态资源需要通过容器来使用</p>
<p>常用的java相关的web服务器软件<br>    WebLogic oracle公司 大型的JavaEE服务器 支持所有的JavaEE规范  收费<br>    WebSphere：IBM 收费<br>    JBOSS:JBOSS公司 收费<br>    Tomcat：Apache基金组织，中小型的JavaEE服务器，仅支持少量的JavaEE规范servlet/jsp，开源</p>
<p>注：JavaEE： Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</p>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.下载 官方网站</span><br><span class="line">2.安装 解压压缩包 安装的目录不要有中文和空格</span><br><span class="line">3.卸载 删除目录就行了</span><br><span class="line">4.启动	bin&#x2F;startup.bat   localhost:8080 一般会把默认端口号改为80 http协议的默认端口号访问不用再输入端口号</span><br><span class="line">5.关闭 </span><br><span class="line">   强制关闭  关闭窗口</span><br><span class="line">   正常关闭  调用shutdown.bat&#x2F; ctrl c 推荐使用</span><br><span class="line"></span><br><span class="line">6.配置 </span><br><span class="line"></span><br><span class="line">部署项目的方式：</span><br><span class="line">1. 直接将项目放在webapps目录下 &#96;http:&#x2F;&#x2F;localhost&#x2F;hello&#x2F;hello.html&#96;</span><br><span class="line">&#x2F;hello 项目的访问路径，虚拟目录 一般会将项目打成war包放到webapps目录下，war包会自动解压缩</span><br><span class="line"></span><br><span class="line">2. 在conf&#x2F;server.xml配置</span><br><span class="line">&lt;Context docBase&#x3D;&quot;D:\hello&quot; path&#x3D;&quot;&#x2F;hi&quot;&#x2F;&gt; docBase是资源所在路径，path是访问时的虚拟路径。server.xml是全局配置文件不建议直接配置</span><br><span class="line"></span><br><span class="line">3.conf\Catalina\localhost创建任意名称的xml，xml的文件名称即为虚拟目录</span><br><span class="line">&lt;Context docBase&#x3D;&quot;D:\hello&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<p>​        </p>
<p><img src="https://i.loli.net/2020/07/07/jNUxvsRF36Z1p8V.png" alt="Tomcat目录结构"></p>
<p>静态项目和动态项目<br>    目录结构：<br>        java动态项目的目录的结构：<br>            |–根目录<br>                |–WEB-INFO （动态项目）<br>                    |–web.xml        web项目的核心配置文件<br>                    |–classes目录 放置字节码文件<br>                    |–lib目录         放置依赖的jar包</p>
<p>将Tomcat集成到IDEA，创建JavaEE项目 run -&gt; edit configuration-&gt;tomcat<br>热部署 update resources</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>概念：server applet  运行在服务器上</p>
<p>动态资源通过逻辑性的Java代码（java类）来执行，依赖于服务器tomcat执行它<br>需要遵守一定的接口，才能被tomcat所识别</p>
<p>Servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别到）的规则<br>自定义Servlet接口的实现类，重写方法。<br>浏览器访问相应的路径就会运行mapping的类中重写的方法</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>快速入门：<br>    1. 创建JavaEE项目<br>    2. 定义Servlet的实现类<br>    3. 重写所有方法<br>    4. 配置servlet</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在web.xml中配置  把实现了Servlet的类映射到一个虚拟路径，浏览器访问该路径就会去调用该类</span><br><span class="line"><span class="comment">&lt;!--    配置servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  <span class="comment">&lt;!--名称自定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cc.landfill.web.servlet.ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> <span class="comment">&lt;!-- 全类名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/test2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>   <span class="comment">&lt;!--虚拟路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在run configuration-&gt;deployment-&gt;application context，把虚拟目录修改为项目名称</p>
<h3 id="执行原理："><a href="#执行原理：" class="headerlink" title="执行原理："></a>执行原理：</h3><p>1.当服务器接收到客户端浏览器的请求后，会解析url路径，获取Servlet的资源路径<br>2.查找web.xml文件，是否有对应的url—pattern标签体内容<br>3.如果有则找到对应的<servlet-class>全类名<br>4.tomcat通过反射把字节码加载进入内存，并且创建对象<br>5.调用相关方法</p>
<p><img src="https://i.loli.net/2020/07/07/P4LFV2aZ1toGn6f.png" alt="image.png"></p>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><p>1.被创建    init() 执行一次方法<br>    默认情况下，第一次被访问时，Servlet被创建</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在<span class="tag">&lt;<span class="name">servlet</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  标签中配置</span><br><span class="line"><span class="comment">&lt;!--        指定servlet的创建时机</span></span><br><span class="line"><span class="comment">            1.在第一次被访问时，创建   默认值为-1</span></span><br><span class="line"><span class="comment">            2.在服务器启动时，创建     0或正整数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>5<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">Servlet 的init()执行一次，说明内存中只有一个Servlet对象，是单例的</span><br><span class="line">多个用户同时访问该对象时，存在线程安全问题，如果加锁会严重影响性能</span><br><span class="line">解决：尽可能不要定义成员变量，用局部变量。即使了定义了成员变量，也不要对其进行赋值，			</span><br><span class="line">只去获取值。</span><br></pre></td></tr></table></figure>
<p>2.提供服务    service()  执行多次<br>    每次访问都会被调用<br>3.被销毁    service() 执行一次<br>    服务器正常关闭的时候执行，Servlet对象销毁，destroy()在被销毁之前执行，用于释放资源</p>
<h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>Servlet3.0:<br>支持注解配置，不再需要web.xml</p>
<p>步骤：</p>
<ol>
<li>选择3.0以上版本，可以不创建web.xml文件</li>
<li>定义Servlet接口的实现类</li>
<li>重写方法</li>
<li>在类上使用webservlet注解配置 @WebServlet(“/test4”) Servlet资源路径</li>
</ol>
<p>IDEA与Tomcat部署</p>
<ol>
<li>IDEA会为每一个tomcat部署的项目单路建立一份配置文件</li>
<li>项目路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工作空间项目: C:\Users\demon\IdeaProjects\day13_tomcat</span><br><span class="line">tomcat部署的项目C:\Users\demon\IdeaProjects\out\artifacts\day13_tomcat_Web_exploded</span><br><span class="line">tomcat真正访问的是tomcat部署的web项目，对应工作空间项目的web目录下的所有资源</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>项目的web-info文件夹不能直接被浏览器访问，静态资源</li>
<li>断点调试。debug </li>
<li>不同项目需要设置不同的虚拟目录 application context 再下一层目录才是实际的资源的位置</li>
</ol>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>Servlet                                 接口<br>    |–GenericServlet      抽象类<br>        |–HttpServlet        抽象类：继承GenericServlet</p>
<p><strong>GenericServlet</strong><br>在GenericServlet类中把其他方法做了空实现，只剩下一个抽象方法void Service(),只要实现一个方法</p>
<p><strong>HttpServlet</strong><br>对http协议的封装，简化操作</p>
<ol>
<li>定义类继承<strong>HttpServlet</strong></li>
<li>重写doGet() 和doPost()   根据请求的方式</li>
</ol>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p>urlpattern</p>
<ol>
<li>一个Servlet可以定义多个访问路径  <code>@WebServlet({&quot;/demo4-1&quot;,&quot;/demo4-2&quot;,&quot;/demo4-3&quot;})</code></li>
<li>路径定义规则：<br><code>/xxx</code><br><code>/xxx/xxx</code>   多层路径  目录结构 可以写成/xxx/*  可以使用通配符，通配符的优先级较低<br> <code>*.do</code>        配合demo4.do来配置 do是自定义的，可以任意</li>
</ol>
<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>概念：代表整个web应用，可以和程序的容器（Server）通信</p>
<p>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过从Servlet继承的方法获取</span></span><br><span class="line">ServletContext context1 = request.getServletContext();</span><br><span class="line"><span class="comment">//通过HttpServlet获取</span></span><br><span class="line">ServletContext context2 = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">//获取的对象是指向同一个引用的 ==</span></span><br></pre></td></tr></table></figure>

<p>功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 获取MIME类型</span><br><span class="line">	MIME类型：在互联网通信过程中定义的一种文件数据类型</span><br><span class="line">	格式：大类型/小类型 text/html image/jpeg</span><br><span class="line">	响应的时候需要设置content-type</span><br><span class="line">	获取：<span class="function">String <span class="title">getMimeType</span><span class="params">(String file)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2. 域对象 共享数据</span></span><br><span class="line"><span class="function">	范围：所有用户所有请求的数据</span></span><br><span class="line"><span class="function">	在一个 Servlet存数据</span></span><br><span class="line"><span class="function">	  ServletContext context </span>= <span class="keyword">this</span>.getServletContext();</span><br><span class="line">      context.setAttribute(<span class="string">"msg"</span>,<span class="string">"hello"</span>);</span><br><span class="line">	在另一个 Servlet读数据</span><br><span class="line">	  ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">      Object msg = context.getAttribute(<span class="string">"msg"</span>);</span><br><span class="line">      System.out.println(msg);</span><br><span class="line">	因为ServletContext的生命周期很长，会一直驻留在内存，存的数据太多会占用内存，谨慎使用</span><br><span class="line">        </span><br><span class="line"><span class="number">3</span>. 获取文件的真实（服务器）路径</span><br><span class="line">	将项目部署在远程的服务器上，需要其在服务器中的真实路径</span><br><span class="line">        </span><br><span class="line"><span class="comment">//项目部署在服务器，访问的不是工作空间，而是项目路径</span></span><br><span class="line"><span class="comment">//默认是找在web目录下的？</span></span><br><span class="line">String realPath = context.getRealPath(<span class="string">"a.txt"</span>);</span><br><span class="line">System.out.println(realPath);  <span class="comment">//C:\Users\demon\IdeaProjects\out\artifacts\day15_response_war_exploded\a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//web目录下</span></span><br><span class="line">String realPath1 = context.getRealPath(<span class="string">"/a.txt"</span>);</span><br><span class="line">System.out.println(realPath1); <span class="comment">//C:\Users\demon\IdeaProjects\out\artifacts\day15_response_war_exploded\a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//web的WEB-INF目录下</span></span><br><span class="line">String realPath2 = context.getRealPath(<span class="string">"/WEB-INF/a.txt"</span>);</span><br><span class="line">System.out.println(realPath2); <span class="comment">//C:\Users\demon\IdeaProjects\out\artifacts\day15_response_war_exploded\WEB-INF\a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//src目录下</span></span><br><span class="line">String realPath3 = context.getRealPath(<span class="string">"/WEB-INF/classes/a.txt"</span>);</span><br><span class="line">System.out.println(realPath3); <span class="comment">//C:\Users\demon\IdeaProjects\out\artifacts\day15_response_war_exploded\WEB-INF\classes\a.txt</span></span><br></pre></td></tr></table></figure>



<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>概念：Hyper Text transfer Protocol    定义了客户端和服务器端通信时，传输的数据的格式  </p>
<p>请求消息/相应消息<br>特点：</p>
<ol>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号为80</li>
<li>基于请求响应模型：一次请求对应一次相应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
<p>版本：</p>
<p>ver1.0 每次请求响应都会建立新的连接</p>
<p>ver1.1 复用连接</p>
<h3 id="Request-Response工作原理"><a href="#Request-Response工作原理" class="headerlink" title="Request/Response工作原理"></a>Request/Response工作原理</h3><ol>
<li>tomcatt服务器会根据url中的资源路径，创建ServletDemo1的对象（Sevelet实现类的对象）</li>
<li>tomcat创建request和response对象，request对象封装了请求消息数据</li>
<li>把两个对象作为参数传给ServletDemo1实例的Service()</li>
<li>通过request对象来获取请求消息数据，通过response对象来设置响应消息数据</li>
<li>服务器在响应浏览器之前，会从封装了响应消息的Response对象中获取响应消息数据，再返回给浏览器</li>
</ol>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><h4 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. 请求行</span><br><span class="line">请求方式 请求url 协议&#x2F;版本</span><br><span class="line">GET&#x2F;login.html HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">请求方式：有7种，常用的有两种</span><br><span class="line">	GET: </span><br><span class="line">	请求参数在请求行中，直接跟在url后面</span><br><span class="line">	请求的url长度有限制</span><br><span class="line">	不安全</span><br><span class="line">		</span><br><span class="line">	POST：</span><br><span class="line">	请求参数在请求体中</span><br><span class="line">	没有url长度限制</span><br><span class="line">	更安全</span><br><span class="line"></span><br><span class="line">2. 请求头</span><br><span class="line">请求头名称：请求头值   以键值对的方式出现</span><br><span class="line"></span><br><span class="line">常见请求头：</span><br><span class="line">Host</span><br><span class="line">User-Agent：浏览器告诉服务器，访问使用的浏览器及其版本，可以解决浏览器的兼容问题（因为浏览器的解析引擎不同），服务器根据</span><br><span class="line">Accept：接收响应的形式</span><br><span class="line">Referer：告诉服务器请求从哪里来</span><br><span class="line">	作用：</span><br><span class="line">		防盗链</span><br><span class="line">		统计：判断流量的来源</span><br><span class="line">Connection； keep-alive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8,en;q&#x3D;0.7,zh-HK;q&#x3D;0.6</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 11</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Cookie: Idea-41d450f1&#x3D;229dd7a7-ea44-4bf7-8c79-ca88718e85a4; JSESSIONID&#x3D;7E11EE42B5820055DDF4EA1FA317A334</span><br><span class="line">Host: localhost</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost</span><br><span class="line">Referer: http:&#x2F;&#x2F;localhost&#x2F;login.html</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.116 Safari&#x2F;537.36</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 请求空行</span><br><span class="line">空行  用于分隔 POST的请求头和请求体</span><br><span class="line">4. 请求体</span><br><span class="line">正文  封装POST请求信息的请求参数，GET方式就没有请求体</span><br><span class="line">字符串格式  username&#x3D;jack</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><h4 id="Request的继承关系"><a href="#Request的继承关系" class="headerlink" title="Request的继承关系"></a>Request的继承关系</h4></li>
</ol>
<p>ServletRequest 接口<br>        |–HttpServletRequest 接口 继承<br>                    |–org.apache.catalina.connector.RequestFacade  Tomcat写的实现类</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol>
<li><h5 id="获取请求消息数据："><a href="#获取请求消息数据：" class="headerlink" title="获取请求消息数据："></a>获取请求消息数据：</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">获取请求行  GET  &#x2F;day14&#x2F;demo1?name&#x3D;jack HTTP&#x2F;1.1</span><br><span class="line">	方法：</span><br><span class="line">	String getMethod()   GET </span><br><span class="line">    String getContextPath()  &#x2F;day14  (*)重点掌握</span><br><span class="line">	String getServletPath() &#x2F;demo1</span><br><span class="line">	String getQueryString  name&#x3D;jack</span><br><span class="line">	String getRequestURI()  &#x2F;day14&#x2F;demo1   (*)</span><br><span class="line">	StringBuffer getRequestURL()  http:&#x2F;&#x2F;localhost&#x2F;day14&#x2F;demo1</span><br><span class="line">	String getProtocol HTTP&#x2F;1.1</span><br><span class="line">	String getRemoteAddr()  获取客户机的ip地址</span><br><span class="line">	</span><br><span class="line">	URL:统一资源定位符  是URL的子集</span><br><span class="line">	URI:统一资源标识符  </span><br><span class="line">	</span><br><span class="line">获取请求头</span><br><span class="line">	String getHeader(String name) 通过请求头的名称获取请求头的值  键值对(*)</span><br><span class="line">	Enumeration&lt;String&gt; getHeaderNames() 获取所有请求头名称 </span><br><span class="line">	</span><br><span class="line">获取请求体</span><br><span class="line">	只有POST方式才有，封装了请求参数</span><br><span class="line">	步骤：</span><br><span class="line">	1.获取流对象</span><br><span class="line">		BufferedRead getReader() 字符流</span><br><span class="line">		ServletInputStream get InputStream() 字节流  在文件上传时在讲</span><br><span class="line">	2.再从流对象中获取数据</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">获取请求参数通用方式  兼容GET和POST</span><br><span class="line">	<span class="function">String <span class="title">getParameter</span><span class="params">(String name)</span> 根据参数名称返回参数值  如<span class="title">getParameter</span><span class="params">(<span class="string">"name"</span>)</span> </span></span><br><span class="line"><span class="function">	String[] <span class="title">getParameterValues</span><span class="params">(String name)</span>  返回参数名的多个value，返回数组</span></span><br><span class="line"><span class="function">	Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span> 获取所有参数名称</span></span><br><span class="line"><span class="function">	Map&lt;String,String[]&gt; <span class="title">getParameterMap</span><span class="params">()</span> 获取所有参数的Map集合</span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function">	TOMCAT8 在GET模式下已经将中文乱码问题解决</span></span><br><span class="line"><span class="function">	POST模式 在获取参数前，设置请求request的变暗 request.<span class="title">setCharacterEncoding</span><span class="params">(<span class="string">"utf-8"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">请求转发:一种在服务器内部进行资源跳转的方式 </span></span><br><span class="line"><span class="function">	步骤：</span></span><br><span class="line"><span class="function">	1.通过request对象获取请求转发器对象RequestDispatcher <span class="title">getRequestDispatcher</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function">	2.使用RequestDispatcherd对象进行转发 forward（ServletRequest request,ServletResponseresponse) </span></span><br><span class="line"><span class="function">    特点：</span></span><br><span class="line"><span class="function">    1.浏览器地址栏不会发生变化</span></span><br><span class="line"><span class="function">    2.服务器内部的资源的转发，转发的路径不能是外部的资源</span></span><br><span class="line"><span class="function">    3.转发是一次请求</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">共享数据</span></span><br><span class="line"><span class="function">    域对象：一个有作用范围的对象，在范围内共享数据</span></span><br><span class="line"><span class="function">    request域：代表一次请求的范围，用于请求转发的多个资源中共享数据</span></span><br><span class="line"><span class="function">    方法：</span></span><br><span class="line"><span class="function">    <span class="title">setAttribute</span><span class="params">(String name,Object obj)</span> 在第一个servlet里设置值</span></span><br><span class="line"><span class="function">    Object <span class="title">getAttribute</span><span class="params">(name)</span>  在得到转发的servlet中去接收值</span></span><br><span class="line"><span class="function">    <span class="title">removeAttribute</span><span class="params">(name)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">获取SevrletContext</span></span><br><span class="line"><span class="function">    ServletContext <span class="title">getServletContext</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>



<h4 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h4><p>用户登录案例需求：<br>    1.编写login.html登录页面<br>        username &amp; password 两个输入框<br>    2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表<br>    3.使用JdbcTemplate技术封装JDBC<br>    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您<br>    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误<br>步骤：</p>
<ol>
<li><p>创建项目，导入html页面，数据库配置文件，jar包</p>
</li>
<li><p>获取数据库连接</p>
</li>
<li><p>创建Javabean，封装user信息</p>
</li>
<li><p>创建UserDAO 操作user表的类，写增删改查方法</p>
</li>
<li><p>写login suc fail Servlet，进行请求转发</p>
</li>
<li><p>BeanUtils工具类<br>JavaBean标准<br>类用public修饰<br>提供空参的构造器<br>成员变量必须使用private修饰<br>提供public的getter和setter</p>
<p>setProperty() getProperty()  populate(Object obj,Map map)封装</p>
</li>
</ol>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><h4 id="响应消息数据格式"><a href="#响应消息数据格式" class="headerlink" title="响应消息数据格式"></a>响应消息数据格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">响应行</span><br><span class="line">	组成：协议&#x2F;版本  响应状态码 状态码描述  HTTP&#x2F;1.1 200 OK</span><br><span class="line">	</span><br><span class="line">	响应状态码：服务器告诉浏览器本次请求和响应的状态，都是3位数，分为5类</span><br><span class="line">		分类：</span><br><span class="line">		1xx  服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx，询问是否还有请求</span><br><span class="line">		2xx  成功。200</span><br><span class="line">		3xx  重定向。302（重定向），资源跳转的方式； 304（访问缓存）</span><br><span class="line">		4xx  客户端错误  404请求路径没有对应的资源 405（请求没有对应的doXxx方法，和请求方式不一致）</span><br><span class="line">		5xx	 服务器错误 500（服务器内部错误）</span><br><span class="line">响应头</span><br><span class="line">	格式 头名称：值</span><br><span class="line">	常见响应头</span><br><span class="line">		Content-Type:type&#x2F;html;charset&#x3D;UTF-8</span><br><span class="line">		Content-disposition 服务器告诉客户端以什么格式打开响应体数据</span><br><span class="line">			默认值：in-line 在当前页面打开</span><br><span class="line">			atttachment；filename&#x3D;xxx 以附件形式打开响应体。用于文件下载</span><br><span class="line">响应空行</span><br><span class="line">响应体</span><br><span class="line">	真实的传输的数据 html页面 ，图片等资源</span><br></pre></td></tr></table></figure>




<h4 id="功能：设置响应消息"><a href="#功能：设置响应消息" class="headerlink" title="功能：设置响应消息"></a>功能：设置响应消息</h4><ol>
<li>设置响应行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">设置状态码：setStatus(int sc)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置响应头</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setHeader(String name,String value)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置响应体</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">步骤</span><br><span class="line">(1)获取输出流</span><br><span class="line">	字符流	PrintWriter getWriter()</span><br><span class="line">	字节流 ServletOutputStream getOutputStream()</span><br><span class="line"></span><br><span class="line">(2)使用输出流将数据输出到客户端浏览器</span><br></pre></td></tr></table></figure>



<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol>
<li><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(1)实现：</span><br><span class="line">&#x2F;* &#x2F;&#x2F;方式一：访问&#x2F;reresponseDemo1 会自动跳转到responseDemo2</span><br><span class="line">&#x2F;&#x2F;1.设置响应行的状态码为302</span><br><span class="line">response.setStatus(302);</span><br><span class="line">&#x2F;&#x2F;2.设置响应头location</span><br><span class="line">response.setHeader(&quot;location&quot;,&quot;&#x2F;day15&#x2F;responseDemo2&quot;);  &#x2F;&#x2F;虚拟路径+资源路径*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式二：</span><br><span class="line">response.sendRedirect(&quot;&#x2F;day15&#x2F;responseDemo2&quot;); &#x2F;&#x2F;可以是任意的url</span><br><span class="line"></span><br><span class="line">(2)特点：转发vs重定向</span><br><span class="line">转发：forward</span><br><span class="line">1.转发地址栏路径不变</span><br><span class="line">2.只能访问当前服务器路径下的资源</span><br><span class="line">3.转发是一次请求，可以使用request对象共享数据</span><br><span class="line"></span><br><span class="line">重定向：redirect</span><br><span class="line">1.地址栏发生变化</span><br><span class="line">2.可以访问其他服务器的资源</span><br><span class="line">3.重定向是两次请求，不再能使用request对象共享数据，两次req&#x2F;resp是不同的</span><br><span class="line"></span><br><span class="line">(3)路径写法</span><br><span class="line">1.相对路径：以.开头 .&#x2F;index.html</span><br><span class="line">	确定当前资源和目标资源之间的位置关系</span><br><span class="line">	例1 .&#x2F; 当前目录</span><br><span class="line">	当前：http:&#x2F;&#x2F;localhost&#x2F;day15&#x2F;location.html</span><br><span class="line">	目标：http:&#x2F;&#x2F;localhost&#x2F;day15&#x2F;responseDemo1</span><br><span class="line">	路径为 .&#x2F;responseDemo1  可以省略为responseDemo1</span><br><span class="line">	例2 ..&#x2F; 后退一级目录</span><br><span class="line">	当前：http:&#x2F;&#x2F;localhost&#x2F;day15&#x2F;htmls&#x2F;location.html</span><br><span class="line">	目标：http:&#x2F;&#x2F;localhost&#x2F;day15&#x2F;responseDemo1</span><br><span class="line">	路径为 ..&#x2F;responseDemo1</span><br><span class="line">	</span><br><span class="line">2.绝对路径： 以&#x2F;开头</span><br><span class="line">	通过绝对路径可以确定唯一资源 如http:&#x2F;&#x2F;localhost&#x2F;day15&#x2F;responseDemo1</span><br><span class="line">			可以省略协议，ip，端口&#x2F;day15&#x2F;responseDemo1</span><br><span class="line">			</span><br><span class="line">3.使用规则：根据使用的对象决定是否加虚拟目录</span><br><span class="line">		给客户端浏览器使用：需要加虚拟目录，如重定向，&lt;a&gt; &lt;form&gt;</span><br><span class="line">		response.sendRedirect(&quot;&#x2F;day15&#x2F;responseDemo2&quot;);</span><br><span class="line">		给服务器使用：不需要加虚拟目录，如转发时,就不要写虚拟目录</span><br><span class="line">		request.getRequestDispatcher(&quot;&#x2F;xxxServlet&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line">4.动态获取虚拟目录</span><br><span class="line">String request.getContextPath()</span><br><span class="line">response.sendRedirect(contextPath+&quot;资源名称&quot;),更改虚拟目录不需要大量调整代码</span><br><span class="line">客户端的虚拟目录也可以动态获取：jsp</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><h5 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*设置编码格式 防止乱码问题</span><br><span class="line">方式一：</span><br><span class="line">&#x2F;&#x2F;在获取流之前，设置流的默认编码（ISO-8859-1）为需要的编码格式</span><br><span class="line">response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">&#x2F;&#x2F;告诉浏览器，服务器发送的消息编码格式，建议浏览器使用该编码解码</span><br><span class="line">response.setHeader(&quot;content-type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot; );  &#x2F;&#x2F;text是html的根本的格式*&#x2F;</span><br><span class="line">&#x2F;&#x2F;方式二</span><br><span class="line">response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.获取字符输出流</span><br><span class="line">PrintWriter pw &#x3D; response.getWriter();  &#x2F;&#x2F;不需要关流，response一次响应结束后自动回销毁，自己做了关闭流的操作</span><br><span class="line">&#x2F;&#x2F;2.输出数据</span><br><span class="line">&#x2F;&#x2F; pw.write(&quot;hello response&quot;);</span><br><span class="line">&#x2F;&#x2F; pw.write(&quot;&lt;h1&gt;hello response&lt;&#x2F;h1&gt;&quot;);</span><br><span class="line">pw.write(&quot;你好啊 响应&quot;);</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><h5 id="服务器输出字节数据到浏览器"><a href="#服务器输出字节数据到浏览器" class="headerlink" title="服务器输出字节数据到浏览器"></a>服务器输出字节数据到浏览器</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class="line">&#x2F;&#x2F;1.获取字节输出流</span><br><span class="line">ServletOutputStream sos &#x3D; response.getOutputStream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.输出数据</span><br><span class="line">sos.write(&quot;hello 你好&quot;.getBytes(&quot;utf-8&quot;));  &#x2F;&#x2F;Chrome默认的字符集是随系统的GBK</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><h5 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">本质是图片 防止恶意的表单注册</span><br><span class="line"></span><br><span class="line">Servlet代码</span><br><span class="line">		int width &#x3D; 100;</span><br><span class="line">        int height &#x3D; 50;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.创建一个对象，验证码图片的对象</span><br><span class="line">        BufferedImage image &#x3D; new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        &#x2F;&#x2F;2.生成验证码图片</span><br><span class="line">        &#x2F;&#x2F;2.1 填充背景色</span><br><span class="line">        Graphics graphics &#x3D; image.getGraphics(); &#x2F;&#x2F;画笔对象</span><br><span class="line">        graphics.setColor(Color.pink);  &#x2F;&#x2F;设置颜色</span><br><span class="line">        graphics.fillRect(0,0,width,height);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.2 画边框</span><br><span class="line">        graphics.setColor(Color.BLUE);</span><br><span class="line">        graphics.drawRect(0,0,width-1,height-1);   &#x2F;&#x2F;0,0是左上角的坐标,边框有一个px</span><br><span class="line">        String str &#x3D;&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.3 写验证码</span><br><span class="line">        for (int i &#x3D; 1; i &lt;5 ; i++) &#123;</span><br><span class="line">            int index &#x3D; random.nextInt(str.length());  &#x2F;&#x2F;随机角标</span><br><span class="line">            char ch &#x3D; str.charAt(index);</span><br><span class="line">            graphics.drawString(ch+&quot;&quot;,width&#x2F;5*i,height&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;2.4 画干扰线</span><br><span class="line">        graphics.setColor(Color.green);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;5 ; i++) &#123;</span><br><span class="line">            int x1 &#x3D; random.nextInt(width);</span><br><span class="line">            int x2 &#x3D; random.nextInt(width);</span><br><span class="line">            int y1 &#x3D; random.nextInt(height);</span><br><span class="line">            int y2 &#x3D; random.nextInt(width);</span><br><span class="line">            graphics.drawLine(x1,y1,x2,y2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;3.输出到页面</span><br><span class="line">        ImageIO.write(image,&quot;jpg&quot;,response.getOutputStream());</span><br><span class="line">        &#x2F;&#x2F;从内存中输出的图片，那这里还有response吗？</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">HTML页面 </span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;img id&#x3D;&quot;checkCode&quot; src&#x3D;&quot;&#x2F;day15&#x2F;checkCodeServlet&quot;&#x2F;&gt;</span><br><span class="line">    &lt;a id&#x3D;&quot;change&quot; href&#x3D;&quot;&quot;&gt;看不清，换一张&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">       &#x2F;* 1.给超链接和图片绑定单击事件</span><br><span class="line">        2.重新设置图片的src属性*&#x2F;</span><br><span class="line">        window.onload &#x3D; function()&#123;</span><br><span class="line">           var img &#x3D; document.getElementById(&quot;checkCode&quot;);</span><br><span class="line">           img.onclick &#x3D; function()&#123;</span><br><span class="line">               &#x2F;&#x2F;加时间戳,解决缓存问题，每次都传一个不重复的参数</span><br><span class="line">               var date &#x3D; new Date().getTime();</span><br><span class="line">               img.src&#x3D;&quot;&#x2F;day15&#x2F;checkCodeServlet?&quot;+date;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="案例：文件下载"><a href="#案例：文件下载" class="headerlink" title="案例：文件下载"></a>案例：文件下载</h4><p>需求：</p>
<ol>
<li>页面显示超链接</li>
<li>点击超链接弹出下载提示框</li>
<li>完成图片文件下载</li>
</ol>
<p>超链接指向的资源，如果可以被浏览器解析，则直接展示，不能解析则下载。使用响应头的content-dispostion:attachment;filename=xxx</p>
<p>步骤：</p>
<ol>
<li><p>定义页面，超链接指向一个servlet，传递资源的名称filename</p>
</li>
<li><p>定义servlet，获取filename，使用字节输入流加载文件进内存</p>
</li>
<li><p>设置响应头 content-dispostion:attachment;filename=xxx</p>
</li>
<li><p>将数据写出到response输出流</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HTML页面</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;&#x2F;day15&#x2F;downloadServlet?filename&#x3D;img1.jpg&quot;&gt;image1&lt;&#x2F;a&gt;  加虚拟路径图片格式</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;downloadServlet&quot;)</span><br><span class="line">public class DownloadServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String filename &#x3D; request.getParameter(&quot;filename&quot;);</span><br><span class="line">        ServletContext servletContext &#x3D; this.getServletContext();</span><br><span class="line">        &#x2F;&#x2F;获取内容类型，设置返回内容类型</span><br><span class="line">        String mimeType &#x3D; servletContext.getMimeType(filename);</span><br><span class="line">        response.setHeader(&quot;content-type&quot;,mimeType);</span><br><span class="line">        &#x2F;&#x2F;获取真实路径</span><br><span class="line">        String realPath &#x3D; servletContext.getRealPath(&quot;img&quot;+filename);  &#x2F;&#x2F;这里不要加&#x2F;web &#x2F;指的就是web，WEB-INF特殊</span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(new File(realPath)); &#x2F;&#x2F;不要加引号</span><br><span class="line">        response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename&#x3D;&quot;+filename);</span><br><span class="line">        ServletOutputStream os &#x3D; response.getOutputStream();</span><br><span class="line">        byte[] buffer &#x3D; new byte[1024*8];</span><br><span class="line">        int len;</span><br><span class="line">        while ((len&#x3D;fis.read(buffer))!&#x3D;-1)&#123;</span><br><span class="line">           os.write(buffer,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下载文件名中文乱码</p>
<p>获取客户端的浏览器版本信息</p>
<p>根据不同版本信息，去设置编码方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解决中文文件名问题：在设置响应头之前设置编码方式</span><br><span class="line">        &#x2F;&#x2F;获取请求头的ua</span><br><span class="line">        String agent &#x3D; request.getHeader(&quot;user-agent&quot;);</span><br><span class="line">        &#x2F;&#x2F;使用工具类方法编码文件名</span><br><span class="line">        filename &#x3D; DownLoadUtils.getFileName(agent, filename);</span><br><span class="line">         response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename&#x3D;&quot;+filename);</span><br></pre></td></tr></table></figure>

<p>可以实现局域网内文件传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.把需要传输的文件放入img文件夹</span><br><span class="line">2.在download.html 修改filename</span><br><span class="line">3.启动服务器</span><br><span class="line">4.从手机端，或者另一台电脑访问192.168.2.116&#x2F;day15&#x2F;download.html</span><br></pre></td></tr></table></figure>
























            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/paranoiddemon.github.io/tags/Java/">Java</a>
		  
			<a href="/paranoiddemon.github.io/tags/Web/">Web</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/paranoiddemon.github.io/posts/how-to-believe.html">
        <span class="next-text nav-default">如何确立一种深信不疑</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
    2020
    <span class="footer-author">Demon.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear" target="_blank" rel="noopener">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    
  





  
    <script type="text/javascript" src="/paranoiddemon.github.io/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/paranoiddemon.github.io/lib/fancybox/jquery.fancybox.pack.js"></script>
  

    <script type="text/javascript" src="/paranoiddemon.github.io/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/paranoiddemon.github.io/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
