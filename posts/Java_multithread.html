<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java-多线程 | LANDFILL</title><link rel="stylesheet" type="text/css" href="/paranoiddemon.github.io/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/paranoiddemon.github.io/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/paranoiddemon.github.io/favicon.ico"><link rel="apple-touch-icon" href="/paranoiddemon.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/paranoiddemon.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/paranoiddemon.github.io/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java-多线程</h1><a id="logo" href="/paranoiddemon.github.io/.">LANDFILL</a><p class="description">当代生活是垃圾</p></div><div id="nav-menu"><a class="current" href="/paranoiddemon.github.io/."><i class="fa fa-home"> 首页</i></a><a href="/paranoiddemon.github.io/about/"><i class="fa fa-user"> 关于</i></a><a href="/paranoiddemon.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/paranoiddemon.github.io/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java-多线程</h1><div class="post-meta">2020-06-25<span> | </span><span class="category"><a href="/paranoiddemon.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><a class="disqus-comment-count" href="/paranoiddemon.github.io/posts/Java_multithread.html#vcomment"><span class="valine-comment-count" data-xid="/paranoiddemon.github.io/posts/Java_multithread.html"></span><span> 条评论</span></a><div class="post-content"><p><img src="https://i.loli.net/2020/06/25/aVB97SkPCuYIWpy.png" alt="多线程"></p>
<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多线程</span></span><br><span class="line"><span class="comment">1.程序、进程、线程</span></span><br><span class="line"><span class="comment">程序program是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进程process程序的一次执行过程，正在运行的一个程序，作为资源分配的单位。有产生存在和消亡的过程-生命周期，</span></span><br><span class="line"><span class="comment">系统在运行时会为每个进程分配不同的内存区域。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">线程thread  进程进一步细化为线程，程序内部的一条执行路径。作为调度和执行的单位，每个线程拥有独立的运行栈</span></span><br><span class="line"><span class="comment">和程序计数器pc，但是共享堆和方法区。进程间的通信更加简便高效。所以就有线程安全的问题。</span></span><br><span class="line"><span class="comment">一个java至少有三个线程  main()主线程 gc()垃圾回收线程 异常处理线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">单核和多核CPU  服务器都是多核的</span></span><br><span class="line"><span class="comment">并行和并发 多个CPU同时执行多个任务/一个CPU(时间片)同时执行多个任务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">多线程的优点</span></span><br><span class="line"><span class="comment">场景：需要同时执行两个或多个任务</span></span><br><span class="line"><span class="comment">程序需要实现一些需要等待的任务。如用户输入 文件读写操作 网络操作 搜索</span></span><br><span class="line"><span class="comment">需要一些后台运行的程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">守护线程/用户线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-lifecycle"><a href="#thread-lifecycle" class="headerlink" title="thread lifecycle"></a>thread lifecycle</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程的生命周期</span></span><br><span class="line"><span class="comment">新建: new了对象</span></span><br><span class="line"><span class="comment">就绪：调用start()  等待cpu分配资源</span></span><br><span class="line"><span class="comment">运行：cpu切换线程，又会失去执行权，或者调用yield(),不同于阻塞</span></span><br><span class="line"><span class="comment">阻塞：join()  sleep(long millis) 等待同步锁 wait() suspend()(deprecated,会导致死锁)</span></span><br><span class="line"><span class="comment">     sleep()时间到，join()的线程结束，获取同步锁，notify() notifyAll() resume()(搭配suspend,deprecated）  回到就    		绪，再等待CPU分配执行权</span></span><br><span class="line"><span class="comment">死亡：执行完run()   stop()  出现error/exception且没处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="thread-scheduling-amp-priority"><a href="#thread-scheduling-amp-priority" class="headerlink" title="thread scheduling &amp;priority"></a>thread scheduling &amp;priority</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程的调度</span></span><br><span class="line"><span class="comment">同优先级线程组成先进先出队列，使用时间片策略</span></span><br><span class="line"><span class="comment">高优先级的，使用优先调度的抢占式策略</span></span><br><span class="line"><span class="comment">但只是从概率上来说，高优先级的线程会被先执行，并不意味着一定先执行高优先级的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">优先级等级</span></span><br><span class="line"><span class="comment">可以设置10档</span></span><br><span class="line"><span class="comment">MAX_PRIORITY:10</span></span><br><span class="line"><span class="comment">MIN_PRIORITY:1</span></span><br><span class="line"><span class="comment">NORM_PRIORITY:5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">涉及的方法：获取和设置</span></span><br><span class="line"><span class="comment">getPriority()</span></span><br><span class="line"><span class="comment">setPriority(int newPriority)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScheduling</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread3 t = <span class="keyword">new</span> MyThread3();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">                Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName()+<span class="string">":"</span>+i);</span><br><span class="line">                setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread类常见方法"><a href="#Thread类常见方法" class="headerlink" title="Thread类常见方法"></a>Thread类常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread类的常用方法</span></span><br><span class="line"><span class="comment">1.start()：启动当前线程 调用当前线程的run()</span></span><br><span class="line"><span class="comment">2.run()：通常需要重写此方法，在创建的线程中需要执行的代码</span></span><br><span class="line"><span class="comment">3.currentThread()：静态方法 返回当前代码执行的线程</span></span><br><span class="line"><span class="comment">4.getName(): 获取当前线程的名字</span></span><br><span class="line"><span class="comment">5.setName(): 设置当前线程的名字  构造器，通过currentThread()或者new对象调用setName()</span></span><br><span class="line"><span class="comment">6.yield(): 释放当前CPU的执行权，但是也可能被CPU继续分配  线程让步</span></span><br><span class="line"><span class="comment">7.join(): 在线程A中调用另外一个线程的join(),线程A进入阻塞状态。等另一个线程执行完了，线程A结束阻塞，再执行A线程</span></span><br><span class="line"><span class="comment">8.stop()：强制结束线程生命期 不推荐使用   //deprecated</span></span><br><span class="line"><span class="comment">9.sleep(long millis): 阻塞millis毫秒  静态方法，可以直接调用。让当前线程睡眠指定的millis毫秒</span></span><br><span class="line"><span class="comment">10.isAlive(): 判断线程是否存活</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 t1 = <span class="keyword">new</span> MyThread1(<span class="string">"进程一"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给主线程命名</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">"main线程"</span>);   <span class="comment">//静态方法 currentThread返回当前的Thread</span></span><br><span class="line">        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"b"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        System.out.println(t1.getName());</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t1.isAlive());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    sleep(1000);</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            if(i == 20)&#123;</span></span><br><span class="line"><span class="comment">//                this.yield(); //释放内存的执行权</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(isAlive());</span><br><span class="line">        <span class="comment">//Thread.currentThread().setName("线程1");//可以设置线程的名字</span></span><br><span class="line">        <span class="comment">// System.out.println(Thread.currentThread().getName());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(String name)</span></span>&#123;  <span class="comment">//通过构造器来给thread命名</span></span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        </p>
<h2 id="二、创建多线程"><a href="#二、创建多线程" class="headerlink" title="二、创建多线程"></a>二、创建多线程</h2><h3 id="BEFOR-JDK5-0"><a href="#BEFOR-JDK5-0" class="headerlink" title="BEFOR JDK5.0"></a>BEFOR JDK5.0</h3><h4 id="1-extends-Thread"><a href="#1-extends-Thread" class="headerlink" title="1. extends Thread"></a>1. extends Thread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.landfill.java;</span><br><span class="line">&#x2F;*</span><br><span class="line">多线程的创建</span><br><span class="line">方式一：继承于Thread类</span><br><span class="line">1.创建一个继承于Thread类的子类</span><br><span class="line">2.重写Thread类的run() 将此线程执行的操作声明在run()中</span><br><span class="line">3.创建子类的对象</span><br><span class="line">4.通过此对象调用start()</span><br><span class="line">&#x2F;&#x2F;注意：</span><br><span class="line">start启动了线程并且去调用run(),不能使用对象直接调用run()</span><br><span class="line">不能再start()来创建一个线程，需要重新创建一个对象。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread t1 &#x3D; new MyThread(); &#x2F;&#x2F;3.创建子类的对象</span><br><span class="line">        t1.start();         &#x2F;&#x2F;4.通过此对象调用start()  作用：①启动当前线程，②调用当前线程的run方法</span><br><span class="line">       &#x2F;&#x2F; t1.run(); 无法启动线程，仍然是在主线程的中进行的。</span><br><span class="line">       &#x2F;&#x2F;以下操作仍然是在main线程执行的</span><br><span class="line">        for(int i &#x3D; 0;i&lt;100;i++)&#123;</span><br><span class="line">            if(i%2!&#x3D;0)&#123;</span><br><span class="line">                System.out.println(&quot;hello------------------------------&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;通过再 new一个线程的对象来调用start</span><br><span class="line">        MyThread t2 &#x3D; new MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class MyThread  extends Thread&#123; &#x2F;&#x2F;1.创建一个继承于Thread类的子类</span><br><span class="line">    @Override               &#x2F;&#x2F;2.重写Thread类的run() 将此线程执行的操作声明在run()中</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i &#x3D; 0;i&lt;100;i++)&#123;</span><br><span class="line">            if(i%2&#x3D;&#x3D;0)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-implements-Runnable"><a href="#2-implements-Runnable" class="headerlink" title="2. implements Runnable"></a>2. implements Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread的创建方式二：实现runnable接口</span></span><br><span class="line"><span class="comment">1.创建Runnable接口的实现类</span></span><br><span class="line"><span class="comment">2.实现类去实现抽象方法 run();</span></span><br><span class="line"><span class="comment">3.创建实现类的对象</span></span><br><span class="line"><span class="comment">4.将此对象作为参数传到Thread类的构造器，创建Thread类的对象</span></span><br><span class="line"><span class="comment">5.Thread类 调用start()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两种方法都得使用Thread类的start()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">比较两种方式：  继承Thread类 vs 实现Runnable</span></span><br><span class="line"><span class="comment">1.继承Thread类，存在单继承的限制，如果已经有其他声明的父类，则不能使用了</span></span><br><span class="line"><span class="comment">2.实现Runnable 可以只创建一个对象，把共享数据封装到实现类里，多个线程共享数据,还可以实现多个接口，没有单继承的限制</span></span><br><span class="line"><span class="comment">所以开发中一般优先用实现Runnable接口,而且从源码可以看到 Thread类实际上就是实现了Runnable接口,何必多绕一步？</span></span><br><span class="line"><span class="comment">两种方式都要重写run() 将线程要执行的代码放入方法体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread4 target = <span class="keyword">new</span> MyThread4();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(target);</span><br><span class="line">        t.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//调用当前线程的run()--&gt;调用了Runnable类型的target的run(),其中target就是传入的参数，</span></span><br><span class="line">        <span class="comment">// 所以也就是调用了实现类重写的run()</span></span><br><span class="line">        <span class="comment">//new Thread(t4).start()</span></span><br><span class="line">        <span class="comment">//再启动一个线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(target);<span class="comment">//可以共用同一个实现类的对象，反正run()是一样的</span></span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);<span class="comment">//不能直接getName了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sad"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        <strong>difference between extends Thread&amp;implements Runnable</strong></p>
<h3 id="AFTER-JDK5-0"><a href="#AFTER-JDK5-0" class="headerlink" title="AFTER JDK5.0"></a>AFTER JDK5.0</h3><h4 id="3-implements-Callable"><a href="#3-implements-Callable" class="headerlink" title="3. implements Callable"></a>3. implements Callable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建线程的方式三：实现Callable接口   ARTER JKD5.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Callable接口创建线程比Runnable更强</span></span><br><span class="line"><span class="comment">可以有返回值</span></span><br><span class="line"><span class="comment">可以抛出异常，可以被外面的操作捕获，获取异常的信息</span></span><br><span class="line"><span class="comment">支持泛型的返回值</span></span><br><span class="line"><span class="comment">需要借助FutureTask类，比如获取返回结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="comment">//1.实现Callable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，写入此线程要执行的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">101</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line"></span><br><span class="line">                sum+= i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable实现类的对象</span></span><br><span class="line">        NumThread t = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4.将Callable实现类的对象作为参数传入，创建 FutureTask对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(t);</span><br><span class="line">        <span class="comment">//5.将FutureTask对象传入，创建Thread对象，调用Start方法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();   <span class="comment">//FutureTask类同时实现了Callable和Runnable，</span></span><br><span class="line">        <span class="comment">// 这里new Thread要求的返回值的形参是Runnable类型的，所以用FutureTask</span></span><br><span class="line">        <span class="comment">//6.如果需要返回值，通过FutureTask调用get()获得 实现的call()返回的对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()返回值。如果不需要返回值</span></span><br><span class="line">            <span class="comment">//可以不写下面的方法</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"总和为"</span>+sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="4-Thread-Pool"><a href="#4-Thread-Pool" class="headerlink" title="4. Thread Pool"></a>4. Thread Pool</h4><p>​            ExecutorSercice API相关功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建线程的方式四：线程池  AFTER JDK5.0</span></span><br><span class="line"><span class="comment">开发中都是用线程池，手动的造线程效率差，和后面的数据库连接池是一个道理,很多时候是用框架实现的，不一定是手写的</span></span><br><span class="line"><span class="comment">1.问题：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</span></span><br><span class="line"><span class="comment">2.思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</span></span><br><span class="line"><span class="comment">3.好处：</span></span><br><span class="line"><span class="comment">    3.1 提高响应的速度：减少了创建线程的时间</span></span><br><span class="line"><span class="comment">    3.2 降低资源的消耗：重复利用线程池中线程  不需要每次都创建</span></span><br><span class="line"><span class="comment">    3.3 便于线程的管理</span></span><br><span class="line"><span class="comment">        - corePoolSize:核心池的大小</span></span><br><span class="line"><span class="comment">        - maximumPoolSize：最大线程数</span></span><br><span class="line"><span class="comment">        - keepAliveTime:线程没有任务时最多保持多长时间后会终止</span></span><br><span class="line"><span class="comment">创建多线程有几种方式：四种 继承Thread  实现Runnable 实现Callable  创建线程池。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number1Thread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">                sum +=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建指定数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//ExecutorService是接口，Executors是该接口的工具类，工厂类</span></span><br><span class="line">        ThreadPoolExecutor service1  = (ThreadPoolExecutor) service;  <span class="comment">//返回的实际是ThreadPoolExecutor的对象，可以向下转型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line">        System.out.println(service.getClass());</span><br><span class="line">        service1.setCorePoolSize(<span class="number">12</span>);<span class="comment">//就可以调用相关的方法去设置线程池的属性，管理线程</span></span><br><span class="line">       <span class="comment">// service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.传入相应的对象，执行指定线程的操作</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());   <span class="comment">//适合用Runnable</span></span><br><span class="line"><span class="comment">//        Number1Thread number1Thread = new Number1Thread();</span></span><br><span class="line"><span class="comment">//        FutureTask futureTask = new FutureTask(number1Thread);  // FutureTask来获取返回值</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Object sum = futureTask.get();</span></span><br><span class="line"><span class="comment">//            System.out.println("总和为"+sum);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125; catch (ExecutionException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        service.submit(number1Thread);  //适合用Callable，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、线程安全"><a href="#三、线程安全" class="headerlink" title="三、线程安全"></a>三、线程安全</h2><h3 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程的同步</span></span><br><span class="line"><span class="comment">1.线程安全问题：重票和错票</span></span><br><span class="line"><span class="comment">2.出现原因：当某个线程操作车票的过程中，尚未完成操作，其他线程就进来了，也操作车票</span></span><br><span class="line"><span class="comment">3.解决方法：当一个线程A操作共享数据时，其他线程不能参与进来，知道线程A操作完，其他线程才可以进来，即使线程A出现阻塞也不能改变</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.在Java中，通过同步机制来解决线程安全问题</span></span><br><span class="line"><span class="comment">    方式一：同步代码块</span></span><br><span class="line"><span class="comment">    synchronized(同步监视器)&#123;</span></span><br><span class="line"><span class="comment">        //需要被同步的代码</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">     说明: 1.操作共享数据的代码，即为需要被同步的代码   --&gt;不能包含过多也不能过少，就变成单线程了</span></span><br><span class="line"><span class="comment">           2.共享数据 多个线程共同操作的变量</span></span><br><span class="line"><span class="comment">           3.同步监视器：锁 任何一个类的对象都可以充当锁，随便new一个object //为什么？</span></span><br><span class="line"><span class="comment">                要求：多个线程必须要共用同一把锁。都是同一个对象</span></span><br><span class="line"><span class="comment">                补充：实现Runnable接口创建的多线程中可以考虑使用this充当锁</span></span><br><span class="line"><span class="comment">                      在继承Thread创建多线程的方式中，慎用this，可以考虑使用当前类充当同步锁 类名.class</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    方式二：同步方法</span></span><br><span class="line"><span class="comment">        如果操作共享数据的代码完整地声明在一个方法中，将方法声明为同步的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        关于同步方法的总结</span></span><br><span class="line"><span class="comment">        同步方法仍然涉及到同步监视器，只是不需要声明</span></span><br><span class="line"><span class="comment">        - 非静态的同步方法，同步监视器是this</span></span><br><span class="line"><span class="comment">        - 静态的同步方法，同步监视器是static</span></span><br><span class="line"><span class="comment">5.同步的方式：线程安全问题解决了；但操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-sychronized-block"><a href="#1-sychronized-block" class="headerlink" title="1. sychronized block"></a>1. sychronized block</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"><span class="comment">//synchronize的使用 ：同步代码块  synchronize(同步监视器）&#123;重复执行的方法&#125;</span></span><br><span class="line"><span class="comment">//创建线程的方式之二：实现Runnable接口 卖票</span></span><br><span class="line"><span class="comment">//区别于继承Thread类，只用new一个实现类的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowRunnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">100</span>; <span class="comment">//此时可以不用static，声明在实现类里的属性。因为只有一个对象，作为参数传递给了三个线程，所以还是只有一个属性,可以放在实现类里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        window1 w1 = <span class="keyword">new</span> window1();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w1);</span><br><span class="line">   <span class="comment">//不用写三个类，同一个类new三个线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w1);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w1);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"线程3"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">window1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (WindowRunnable.total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//this是唯一的对象，只有用于实现Runnable接口的方法</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    WindowRunnable.total--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":剩余"</span> + WindowRunnable.total + <span class="string">"张票"</span> + <span class="string">" 你的票号为："</span> +</span><br><span class="line">                            (WindowRunnable.total + <span class="number">1</span>));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-sychronized-method"><a href="#2-sychronized-method" class="headerlink" title="2 .sychronized method"></a>2 .sychronized method</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用同步方法解决实现Runnable接口的线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowImpleMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window w = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3= <span class="keyword">new</span> Thread(w);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"线程3"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(WindowTest.TOTAL_TICKETS&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;  <span class="comment">//同步监视器是this</span></span><br><span class="line">        <span class="keyword">if</span> (WindowTest.TOTAL_TICKETS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            WindowTest.TOTAL_TICKETS--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" left:"</span> + WindowTest.TOTAL_TICKETS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread类继承创建的线程 使用同步方法解决线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowExtMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        windows2 w1 = <span class="keyword">new</span> windows2();</span><br><span class="line">        windows2 w2 = <span class="keyword">new</span> windows2();</span><br><span class="line">        windows2 w3 = <span class="keyword">new</span> windows2();</span><br><span class="line">        w3.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">windows2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// private static  void show()&#123;  //锁的问题，同步监视器有三个了</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;   <span class="comment">//this是当前的类</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);  <span class="comment">//父类的静态方法，可以直接调用</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ticket--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" left:"</span> + ticket);</span><br><span class="line">            <span class="comment">//静态方法内部不用直接调用动态方法，需通过 对象.方法 的方式来调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="单例模式懒汉式改写成线程安全的"><a href="#单例模式懒汉式改写成线程安全的" class="headerlink" title="单例模式懒汉式改写成线程安全的"></a>单例模式懒汉式改写成线程安全的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用同步机制将单例模式中的懒汉式改写为线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank bank = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title">getBank</span><span class="params">()</span></span>&#123;  <span class="comment">//可能几个线程来同时调用，就会存在线程安全问题,静态同步方法的锁是类本身</span></span><br><span class="line">        <span class="comment">//方式一：同步代码块，效率差，每次都会进去判断，和直接用同步方法一样，效率低</span></span><br><span class="line"><span class="comment">//        synchronized(Bank.class) &#123;</span></span><br><span class="line"><span class="comment">//            if (bank == null) &#123;</span></span><br><span class="line"><span class="comment">//                bank = new Bank();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            return bank;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(bank == <span class="keyword">null</span>)&#123;     <span class="comment">//后面的大部分线程就不进去了  效率更高</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Bank<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (bank == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bank = <span class="keyword">new</span> Bank();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ReentrantLock-AFTER-JDK5-0"><a href="#ReentrantLock-AFTER-JDK5-0" class="headerlink" title="ReentrantLock(AFTER JDK5.0)"></a>ReentrantLock(AFTER JDK5.0)</h3><h4 id="3-lock-unlock"><a href="#3-lock-unlock" class="headerlink" title="3. lock/unlock"></a>3. lock/unlock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决线程安全问题的方式三：Lock锁   --AFTER JDK5.0</span></span><br><span class="line"><span class="comment">synchronized 和 lock的异同？</span></span><br><span class="line"><span class="comment">相同：都可以解决线程安全的问题</span></span><br><span class="line"><span class="comment">不同：synchronized 等执行完代码块或者同步方法，再自动释放同步监视器</span></span><br><span class="line"><span class="comment">      lock需要手动的启动同步，手动的结束同步 unlock</span></span><br><span class="line"><span class="comment">ReentrantLock是Lock接口的实现类，扩展性更好，更多子类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">建议优先度：lock  同步代码块（已经进入方法体） 同步方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化reentrantlock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);   <span class="comment">//fair 先进先出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               lock.lock();         <span class="comment">//使用try-catch结构，加锁</span></span><br><span class="line">               <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">"票号为："</span>+tickets);</span><br><span class="line">                   tickets--;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();       <span class="comment">//解锁</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window w = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        difference between ReentrantLock&amp;sychronized</p>
<h3 id="线程同步问题DeadLock"><a href="#线程同步问题DeadLock" class="headerlink" title="线程同步问题DeadLock"></a>线程同步问题DeadLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程的死锁问题</span></span><br><span class="line"><span class="comment">定义：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成的线程的死锁</span></span><br><span class="line"><span class="comment">出现死锁后不会出现异常，不会提示，只是所有线程都处于阻塞状态，无法继续，使用时要避免死锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决方法</span></span><br><span class="line"><span class="comment">1.专门的算法、原则</span></span><br><span class="line"><span class="comment">2.尽量减少使用同步资源</span></span><br><span class="line"><span class="comment">3.避免嵌套同步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer s2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">"a"</span>);</span><br><span class="line">                    s2.append(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                        s1.append(<span class="string">"b"</span>);</span><br><span class="line">                        s2.append(<span class="string">"2"</span>);</span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">"c"</span>);</span><br><span class="line">                    s2.append(<span class="string">"3"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                        s1.append(<span class="string">"d"</span>);</span><br><span class="line">                        s2.append(<span class="string">"4"</span>);</span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span>&#123;  <span class="comment">//锁 A类的对象 a</span></span><br><span class="line">		System.out.println(<span class="string">"当前线程名: "</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">" 进入了A实例的foo方法"</span>); <span class="comment">// ①</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"当前线程名: "</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">" 企图调用B实例的last方法"</span>); <span class="comment">// ③</span></span><br><span class="line">		b.last();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> </span>&#123;    <span class="comment">//同步监视器 a</span></span><br><span class="line">		System.out.println(<span class="string">"进入了A类的last方法内部"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(A a)</span> </span>&#123;  <span class="comment">//同步监视器 b</span></span><br><span class="line">		System.out.println(<span class="string">"当前线程名: "</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">" 进入了B实例的bar方法"</span>); <span class="comment">// ②</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"当前线程名: "</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">" 企图调用A实例的last方法"</span>); <span class="comment">// ④</span></span><br><span class="line">		a.last();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> </span>&#123;   <span class="comment">//同步监视器 对象b</span></span><br><span class="line">		System.out.println(<span class="string">"进入了B类的last方法内部"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	A a = <span class="keyword">new</span> A();</span><br><span class="line">	B b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread.currentThread().setName(<span class="string">"主线程"</span>);</span><br><span class="line">		<span class="comment">// 调用a对象的foo方法</span></span><br><span class="line">		a.foo(b);</span><br><span class="line">		System.out.println(<span class="string">"进入了主线程之后"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread.currentThread().setName(<span class="string">"副线程"</span>);</span><br><span class="line">		<span class="comment">// 调用b对象的bar方法</span></span><br><span class="line">		b.bar(a);</span><br><span class="line">		System.out.println(<span class="string">"进入了副线程之后"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DeadLock1 dl = <span class="keyword">new</span> DeadLock1();</span><br><span class="line">		<span class="keyword">new</span> Thread(dl).start();</span><br><span class="line">		dl.init();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        </p>
<h2 id="四、线程通信"><a href="#四、线程通信" class="headerlink" title="四、线程通信"></a>四、线程通信</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程通信</span></span><br><span class="line"><span class="comment">两个线程交替打印1-100。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">涉及的三个方法</span></span><br><span class="line"><span class="comment">wait(): 一旦执行此方法，线程阻塞，释放同步监视器</span></span><br><span class="line"><span class="comment">notifyAll()：一旦执行此方法，唤醒所有被wait的线程</span></span><br><span class="line"><span class="comment">notify();只唤醒一个线程，如果有多个wait的线程，就唤醒优先级高的线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.使用前提：只能在同步方法和同步代码块中的调用，使用ReentrantLock以另外的方式通信</span></span><br><span class="line"><span class="comment">2.三个方法的调用者必须是同步方法和同步代码块中的同步监视器，否则会报错</span></span><br><span class="line"><span class="comment">//java.lang.IllegalMonitorStateException，this和同步监视器不一样的话会报错</span></span><br><span class="line"><span class="comment">在类中调用方法的时候，非静态方法，省略了“this，” 静态方法省略了 “类.”</span></span><br><span class="line"><span class="comment">3.因为任何一个类的对象都可以充当同步监视器，所以任何一个对象都得有这三个方法，所以这三个方法时定义在java.lang.Object类中的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.比较：sleep()和wait()的异同</span></span><br><span class="line"><span class="comment">  相同：当前线程都会进入阻塞状态</span></span><br><span class="line"><span class="comment">  不同：在都用在同步代码块和同步方法中的时候，sleep()不会释放锁，wait()会释放锁</span></span><br><span class="line"><span class="comment">         sleep()声明在Thread且是静态的，wait()声明在Object类</span></span><br><span class="line"><span class="comment">         sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块和同步方法中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">                obj.notifyAll();   <span class="comment">//notifyAll()唤醒所有线程，按优先级</span></span><br><span class="line">                <span class="comment">//java.lang.IllegalMonitorStateException</span></span><br><span class="line">                <span class="keyword">if</span>(num&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sleep(<span class="number">10</span>);    <span class="comment">//不释放锁，不同于wait</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+num);</span><br><span class="line">                    num++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();                          <span class="comment">//使得调用该方法的线程进入阻塞状态，一旦执行wait() 会释放锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadComumnication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number num = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(num);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(num);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="producer-consumer-problem"><a href="#producer-consumer-problem" class="headerlink" title="producer-consumer problem"></a>producer-consumer problem</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.landfill.java3;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程通信的应用： Producer-Consumer problem(Bounded-buffer problem)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分析：生产者线程  消费者线程</span></span><br><span class="line"><span class="comment">共享数据：clerk</span></span><br><span class="line"><span class="comment">解决线程安全问题：同步机制</span></span><br><span class="line"><span class="comment">涉及线程的通信</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//成产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">procudeProcuct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">20</span>)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":生产产品"</span>+num);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumeProcuct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":消费产品"</span>+num);</span><br><span class="line">            num--;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":开始成产产品"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            clerk.procudeProcuct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":开始消费产品"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            clerk.consumeProcuct();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk c = <span class="keyword">new</span> Clerk();</span><br><span class="line">        Producer p1 = <span class="keyword">new</span> Producer(c);</span><br><span class="line">        Consumer c1 = <span class="keyword">new</span> Consumer(c);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        t1.setName(<span class="string">"生产者"</span>);</span><br><span class="line">        t2.setName(<span class="string">"消费者"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div><script type="text/javascript" src="/paranoiddemon.github.io/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://paranoiddemon.github.io/blog/posts/Java_multithread.html" data-id="ckc0020i70000v8us56ih3enc" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsklEQVR42u3awW7jMAwE0Pz/T2evCxTxzpASkC6eT0HrOno6mOqQr1d8vX9cP3++f8Kn6+87XzcuPDw8vPXSk0U8PyeBPa/n+efJmvHw8PBu85LHPf/Vp/ufC0myiXmRwMPDw/uNvLw8JM/Ew8PD+/94yTE3P0DnYQQeHh7eN/A2EWp+CN5syvWsBQ8PDy/m5V2k7/l8pb+Hh4eHt+6q58HBLFzIn/YeXXh4eHg3ePkLNwe3h+a8GdauEw8PD+8Gb7PQdoBgNl6weQIeHh7ebd4+yUii3k0BqP8KDw8P7xovKQZ5ZNBuX1J+8pGsj/8r4OHh4R3i7ceh2pgg35pZyVn19PDw8PCC37bNrXz0Kln6pg2WbDoeHh7eDV7+9Zvlzg7ox6IQPDw8vAu8fEH5az0/2c6GDNqxBjw8PLyzvE0okCyojSpmecLH+/Hw8PCO8tom1qzhlG9Bu1n/KCF4eHh4F3jJKzgh5V85KxLtMEHRDMPDw8Mree/yyrON9v686VXHEHh4eHhHebNX/yw+mB3Hj307Hh4e3iFePko1O0Anz2yHCYojOx4eHt4FXp5YtHHtqQGCvJzUM2V4eHh4I95sFCA/ghcpchsuBBuEh4eHd4OX/GP//HnWvto8rY4q8PDw8C7wZm37WWu/Pe8nUUgREOPh4eEd4uWv6eRr8vvzCLiNdFcLxcPDwyvnkfKAtY0JNoNTm9/i4eHh3ePN4tdNIZkNLtSbiIeHh3eU9y6vWRzQNsmOlQc8PDy8C7xZU78tJ/nWnP2Mh4eHd4/XFoO8POQn2zzeTZptxcEaDw8Pb8GbvdDbN/CNKyoMeHh4eF/Ay8/pm5ijLQN4eHh438/Li0S7ZbMNKnpoeHh4eGveJgjYBL6zI3ixNjw8PLwLvM1w1amIth2oOhxw4OHh4aW8PyVtNcp6wnj7AAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/paranoiddemon.github.io/tags/Java/"><i class="fa fa-tag"></i>Java</a></div><div class="post-nav"><a class="next" href="/paranoiddemon.github.io/posts/HexoSync.html">更换电脑Hexo博客迁移</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'F4fuINw4fDM77aFwYEmAzsW3-gzGzoHsz',
  appKey:'mMUlvMhTRvKI3Akc8WuVc2EU',
  placeholder:'你来讲两句',
  avatar:'mp',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/paranoiddemon.github.io/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/paranoiddemon.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/paranoiddemon.github.io/categories/%E7%BB%8F%E9%AA%8C/">经验</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/paranoiddemon.github.io/tags/Java/" style="font-size: 15px;">Java</a> <a href="/paranoiddemon.github.io/tags/blog/" style="font-size: 15px;">blog</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/Java_multithread.html">Java-多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/HexoSync.html">更换电脑Hexo博客迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/PSN_GOG_connect.html">GOG连接PSN"Playstation connection timed out"问题解决</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/Java_OOP.html">Java-面向对象</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/thoughtsof202006.html">2020/06</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/Java_basics.html">Java-基本语法</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/HKelection.html">香港选举制度</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/MySql_select.html">MySql学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/speedy_revovery.html">Wish You A Speedy Recovery</a></li><li class="post-list-item"><a class="post-list-link" href="/paranoiddemon.github.io/posts/thoughtsof202005.html">2020/05</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/paranoiddemon.github.io/." rel="nofollow">LANDFILL.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/paranoiddemon.github.io/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/paranoiddemon.github.io/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/paranoiddemon.github.io/css/search.css?v=0.0.0"><script type="text/javascript" src="/paranoiddemon.github.io/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/paranoiddemon.github.io/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/paranoiddemon.github.io/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/paranoiddemon.github.io/js/smartresize.js?v=0.0.0"></script></div></body></html>